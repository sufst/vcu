############################################################
#               :
#   File        :   testbench_generate.py
#               :
#   Author(s)   :   Tim Brewis (tab1g19@soton.ac.uk)
#               :
#   Description :   C code generator for VCU throttle input
#               :   testbench look-up tables
#               :
############################################################

import datetime
import os
import sys

############################################################
# constants
############################################################

class Colours:
    """Colours for printing
    """
    Header = '\033[95m'
    Blue = '\033[94m'
    Cyan = '\033[96m'
    Green = '\033[92m'
    Warning = '\033[93m'
    Error = '\033[91m'
    End = '\033[0m'
    Bold = '\033[1m'
    Underline = '\033[4m'

############################################################
# main function
############################################################

def run():

    # parameters / constants
    time_heading = 'Time'
    throttle_heading = 'Throttle'
    torque_heading = 'TrqUsed'
    output_file_name ='throttle_testbench_data'

    throttle_resolution = 15

    # create output files
    script_path = os.path.abspath(os.path.dirname(__file__))
    h_file_name = script_path + '/' + output_file_name + '.h'
    c_file_name = script_path + '/' + output_file_name + '.c'

    h_file = open(h_file_name, 'w+')
    c_file = open(c_file_name, 'w+')

    h_file.write(docs_header(h_file_name))
    c_file.write(docs_header(c_file_name))

    include_guard = output_file_name.upper() + '_H'
    h_file.write('#include <stdint.h>\n\n')
    h_file.write('#ifndef ' + include_guard + '\n')
    h_file.write('#define ' + include_guard + '\n\n')

    c_file.write('#include \"' + h_file_name.split('/')[-1] + '\"\n\n')

    # go through each file in ./csv
    csv_dir = script_path + '/csv/'
    csv_files = [csv_dir + f for f in os.listdir(csv_dir) if os.path.isfile(os.path.join(csv_dir, f))]

    print(Colours.Header + '\nGenerating lookup tables:' + Colours.End)

    file_count = 0
    for file_name in csv_files:

        print('->', file_name)

        # ignore anything that isn't a csv
        if file_name.split('.')[-1] != 'csv':
            continue

        # extract data from file
        file = open(file_name, 'r')
        data = {}

        for line in file:
            values = line.split(',')
            data[values[0]] = values[1:]

        # convert data
        # -> times are in seconds (?) mapped to ms
        # -> throttle input is [0, 1] mapped to output [0, 2^throttle_resolution - 1]
        # -> torques unused but read incase we need it later
        max_throttle = pow(2, throttle_resolution) - 1
        
        times_ms = [int(float(x) * 1000) for x in data[time_heading]]
        throttles = [int(float(x) * max_throttle) for x in data[throttle_heading]]
        torques = [float(x) for x in data[torque_heading]]

        if len(times_ms) != len(throttles):
            error_str = Colours.Error + 'Error: number of data points for time and torque not equal\n' + Colours.End
            sys.exit(error_str)

        # generate C code lookup tables
        prototype, array = to_hex_array_code(times_ms, 'time_lookup_' + str(file_count))
        c_code = array + '\n\n'
        h_code = prototype + '\n'

        prototype, array = to_hex_array_code(throttles, 'throttle_lookup_' + str(file_count))
        c_code += array
        h_code += prototype

        # write to files
        c_file.write(c_code)
        h_file.write(h_code)

        c_file.write('\n\n')
        h_file.write('\n\n')

        # cleanup
        file.close()
        file_count += 1

    # finish up files
    h_file.write('\n\n#endif \n')

    # cleanup and exit
    c_file.close()
    h_file.close()
    print(Colours.Green + 'Done.\n' + Colours.End)

############################################################
# code generators
############################################################

def docs_header(file_name):

    """Generates a doxygen documentation header

    Parameters
    ----------
    file_name : str
        The name of the file to generate the docs header for
    """

    docs =  '/***************************************************************************\n'
    docs += ' * @file   ' + file_name.split('/')[-1] + '\n'
    docs += ' * @author Auto-generated by ' + __file__.split('/')[-1] + '\n' 
    docs += ' * @date   ' + datetime.date.today().strftime('%Y-%m-%d') + '\n'
    docs += ' * @brief  Data for throttle input test bench\n'
    docs += '***************************************************************************/\n\n'

    return docs

def to_hex_array_code(data, array_name, elements_per_line=16, num_hex_digits=4):

    """Converts a list of integers to a C array

    Parameters
    ----------
    data : list
        List of data points (maximum 16 bits)
    array_name : str
        Name to give the C array
    elements_per_line : int
        Number of array elements per line of code
    num_hex_digits : int
        Number of hex digits to use to represent the data

    Returns
    -------
    tuple(2)
        Prototype for the array, array itself
    """

    max_data = int('0x' + 'F' * num_hex_digits, 16)

    array = 'const uint16_t ' + array_name + ' [' + str(len(data)) + ']'
    prototype = 'extern ' + array + ';'
    source = array + ' = {\n\t'

    for i in range(len(data)):

        if data[i] > max_data:
            error_str = Colours.Error + 'Error: Data at index ' + str(i) + \
                        ' for ' + array_name + ' exceeds range of uint16_t' \
                        + Colours.End + '\n'
            sys.exit(error_str)

        source += "{0:#0{1}x}".format(int(data[i]), 2 + num_hex_digits)
        source += ', '

        if i % elements_per_line == elements_per_line - 1:
            source += '\n\t'

    source += '\n};'
    
    return (prototype, source)

############################################################
# driver code / main
############################################################

if __name__  == "__main__":
    run()
